Info file gcc.info, produced by Makeinfo, -*- Text -*- from input
file gcc.texinfo.

This file documents the use and the internals of the GNU compiler.

Copyright (C) 1988 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled ``GNU CC General Public License'' is
included exactly as in the original, and provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled ``GNU CC General Public
License'' and this permission notice may be included in translations
approved by the Free Software Foundation instead of in the original
English.



File: gcc.info,  Node: Comparisons,  Next: Bit Fields,  Prev: Arithmetic,  Up: RTL

Comparison Operations
=====================

Comparison operators test a relation on two operands and are
considered to represent the value 1 if the relation holds, or zero if
it does not.  The mode of the comparison is determined by the
operands; they must both be valid for a common machine mode.  A
comparison with both operands constant would be invalid as the
machine mode could not be deduced from it, but such a comparison
should never exist in RTL due to constant folding.

Inequality comparisons come in two flavors, signed and unsigned. 
Thus, there are distinct expression codes `gt' and `gtu' for signed
and unsigned greater-than.  These can produce different results for
the same pair of integer values: for example, 1 is signed
greater-than -1 but not unsigned greater-than, because -1 when
regarded as unsigned is actually `0xffffffff' which is greater than 1.

The signed comparisons are also used for floating point values. 
Floating point comparisons are distinguished by the machine modes of
the operands.

The comparison operators may be used to compare the condition codes
`(cc0)' against zero, as in `(eq (cc0) (const_int 0))'.  Such a
construct actually refers to the result of the preceding instruction
in which the condition codes were set.  The above example stands for
1 if the condition codes were set to say ``zero'' or ``equal'', 0
otherwise.  Although the same comparison operators are used for this
as may be used in other contexts on actual data, no confusion can
result since the machine description would never allow both kinds of
uses in the same context.

`(eq X Y)'
     1 if the values represented by X and Y are equal, otherwise 0.

`(ne X Y)'
     1 if the values represented by X and Y are not equal, otherwise 0.

`(gt X Y)'
     1 if the X is greater than Y.  If they are fixed-point, the
     comparison is done in a signed sense.

`(gtu X Y)'
     Like `gt' but does unsigned comparison, on fixed-point numbers
     only.

`(lt X Y)'
`(ltu X Y)'
     Like `gt' and `gtu' but test for ``less than''.

`(ge X Y)'
`(geu X Y)'
     Like `gt' and `gtu' but test for ``greater than or equal''.

`(le X Y)'
`(leu X Y)'
     Like `gt' and `gtu' but test for ``less than or equal''.

`(if_then_else COND THEN ELSE)'
     This is not a comparison operation but is listed here because it
     is always used in conjunction with a comparison operation.  To
     be precise, COND is a comparison expression.  This expression
     represents a choice, according to COND, between the value
     represented by THEN and the one represented by ELSE.

     On most machines, `if_then_else' expressions are valid only to
     express conditional jumps.



File: gcc.info,  Node: Bit Fields,  Next: Conversions,  Prev: Comparisons,  Up: RTL

Bit-fields
==========

Special expression codes exist to represent bit-field instructions. 
These types of expressions are lvalues in RTL; they may appear on the
left side of a assignment, indicating insertion of a value into the
specified bit field.

`(sign_extract:SI LOC SIZE POS)'
     This represents a reference to a sign-extended bit-field
     contained or starting in LOC (a memory or register reference). 
     The bit field is SIZE bits wide and starts at bit POS.  The
     compilation option `BITS_BIG_ENDIAN' says which end of the
     memory unit POS counts from.

     Which machine modes are valid for LOC depends on the machine,
     but typically LOC should be a single byte when in memory or a
     full word in a register.

`(zero_extract:SI LOC SIZE POS)'
     Like `sign_extract' but refers to an unsigned or zero-extended
     bit field.  The same sequence of bits are extracted, but they
     are filled to an entire word with zeros instead of by
     sign-extension.



File: gcc.info,  Node: Conversions,  Next: RTL Declarations,  Prev: Bit Fields,  Up: RTL

Conversions
===========

All conversions between machine modes must be represented by explicit
conversion operations.  For example, an expression which is the sum
of a byte and a full word cannot be written as `(plus:SI (reg:QI 34)
(reg:SI 80))' because the `plus' operation requires two operands of
the same machine mode.  Therefore, the byte-sized operand is enclosed
in a conversion operation, as in

     (plus:SI (sign_extend:SI (reg:QI 34)) (reg:SI 80))

The conversion operation is not a mere placeholder, because there may
be more than one way of converting from a given starting mode to the
desired final mode.  The conversion operation code says how to do it.

`(sign_extend:M X)'
     Represents the result of sign-extending the value X to machine
     mode M.  M must be a fixed-point mode and X a fixed-point value
     of a mode narrower than M.

`(zero_extend:M X)'
     Represents the result of zero-extending the value X to machine
     mode M.  M must be a fixed-point mode and X a fixed-point value
     of a mode narrower than M.

`(float_extend:M X)'
     Represents the result of extending the value X to machine mode
     M.  M must be a floating point mode and X a floating point value
     of a mode narrower than M.

`(truncate:M X)'
     Represents the result of truncating the value X to machine mode
     M.  M must be a fixed-point mode and X a fixed-point value of a
     mode wider than M.

`(float_truncate:M X)'
     Represents the result of truncating the value X to machine mode
     M.  M must be a floating point mode and X a floating point value
     of a mode wider than M.

`(float:M X)'
     Represents the result of converting fixed point value X,
     regarded as signed, to floating point mode M.

`(unsigned_float:M X)'
     Represents the result of converting fixed point value X,
     regarded as unsigned, to floating point mode M.

`(fix:M X)'
     When M is a fixed point mode, represents the result of
     converting floating point value X to mode M, regarded as signed.
     How rounding is done is not specified, so this operation may be
     used validly in compiling C code only for integer-valued operands.

`(unsigned_fix:M X)'
     Represents the result of converting floating point value X to
     fixed point mode M, regarded as unsigned.  How rounding is done
     is not specified.

`(fix:M X)'
     When M is a floating point mode, represents the result of
     converting floating point value X (valid for mode M) to an
     integer, still represented in floating point mode M, by rounding
     towards zero.



File: gcc.info,  Node: RTL Declarations,  Next: Side Effects,  Prev: Conversions,  Up: RTL

Declarations
============

Declaration expression codes do not represent arithmetic operations
but rather state assertions about their operands.

`(strict_low_part (subreg:M (reg:N R) 0))'
     This expression code is used in only one context: operand 0 of a
     `set' expression.  In addition, the operand of this expression
     must be a `subreg' expression.

     The presence of `strict_low_part' says that the part of the
     register which is meaningful in mode N, but is not part of mode
     M, is not to be altered.  Normally, an assignment to such a
     subreg is allowed to have undefined effects on the rest of the
     register when M is less than a word.



File: gcc.info,  Node: Side Effects,  Next: Incdec,  Prev: RTL Declarations,  Up: RTL

Side Effect Expressions
=======================

The expression codes described so far represent values, not actions. 
But machine instructions never produce values; they are meaningful
only for their side effects on the state of the machine.  Special
expression codes are used to represent side effects.

The body of an instruction is always one of these side effect codes;
the codes described above, which represent values, appear only as the
operands of these.

`(set LVAL X)'
     Represents the action of storing the value of X into the place
     represented by LVAL.  LVAL must be an expression representing a
     place that can be stored in: `reg' (or `subreg' or
     `strict_low_part'), `mem', `pc' or `cc0'.

     If LVAL is a `reg', `subreg' or `mem', it has a machine mode;
     then X must be valid for that mode.

     If LVAL is a `reg' whose machine mode is less than the full
     width of the register, then it means that the part of the
     register specified by the machine mode is given the specified
     value and the rest of the register receives an undefined value. 
     Likewise, if LVAL is a `subreg' whose machine mode is narrower
     than `SImode', the rest of the register can be changed in an
     undefined way.

     If LVAL is a `strict_low_part' of a `subreg', then the part of
     the register specified by the machine mode of the `subreg' is
     given the value X and the rest of the register is not changed.

     If LVAL is `(cc0)', it has no machine mode, and X may have any
     mode.  This represents a ``test'' or ``compare'' instruction.

     If LVAL is `(pc)', we have a jump instruction, and the
     possibilities for X are very limited.  It may be a `label_ref'
     expression (unconditional jump).  It may be an `if_then_else'
     (conditional jump), in which case either the second or the third
     operand must be `(pc)' (for the case which does not jump) and
     the other of the two must be a `label_ref' (for the case which
     does jump).  X may also be a `mem' or `(plus:SI (pc) Y)', where
     Y may be a `reg' or a `mem'; these unusual patterns are used to
     represent jumps through branch tables.

`(return)'
     Represents a return from the current function, on machines where
     this can be done with one instruction, such as Vaxes.  On
     machines where a multi-instruction ``epilogue'' must be executed
     in order to return from the function, returning is done by
     jumping to a label which precedes the epilogue, and the `return'
     expression code is never used.

`(call FUNCTION NARGS)'
     Represents a function call.  FUNCTION is a `mem' expression
     whose address is the address of the function to be called. 
     NARGS is an expression which can be used for two purposes: on
     some machines it represents the number of bytes of stack
     argument; on others, it represents the number of argument
     registers.

     Each machine has a standard machine mode which FUNCTION must
     have.  The machine description defines macro `FUNCTION_MODE' to
     expand into the requisite mode name.  The purpose of this mode
     is to specify what kind of addressing is allowed, on machines
     where the allowed kinds of addressing depend on the machine mode
     being addressed.

`(clobber X)'
     Represents the storing or possible storing of an unpredictable,
     undescribed value into X, which must be a `reg' or `mem'
     expression.

     One place this is used is in string instructions that store
     standard values into particular hard registers.  It may not be
     worth the trouble to describe the values that are stored, but it
     is essential to inform the compiler that the registers will be
     altered, lest it attempt to keep data in them across the string
     instruction.

     X may also be null--a null C pointer, no expression at all. 
     Such a `(clobber (null))' expression means that all memory
     locations must be presumed clobbered.

     Note that the machine description classifies certain hard
     registers as ``call-clobbered''.  All function call instructions
     are assumed by default to clobber these registers, so there is
     no need to use `clobber' expressions to indicate this fact. 
     Also, each function call is assumed to have the potential to
     alter any memory location.

`(use X)'
     Represents the use of the value of X.  It indicates that the
     value in X at this point in the program is needed, even though
     it may not be apparent why this is so.  Therefore, the compiler
     will not attempt to delete instructions whose only effect is to
     store a value in X.  X must be a `reg' expression.

`(parallel [X0 X1 ...])'
     Represents several side effects performed in parallel.  The
     square brackets stand for a vector; the operand of `parallel' is
     a vector of expressions.  X0, X1 and so on are individual side
     effects--expressions of code `set', `call', `return', `clobber'
     or `use'.

     ``In parallel'' means that first all the values used in the
     individual side-effects are computed, and second all the actual
     side-effects are performed.  For example,

          (parallel [(set (reg:SI 1) (mem:SI (reg:SI 1)))
                     (set (mem:SI (reg:SI 1)) (reg:SI 1))])

     says unambiguously that the values of hard register 1 and the
     memory location addressed by it are interchanged.  In both
     places where `(reg:SI 1)' appears as a memory address it refers
     to the value in register 1 *before* the execution of the
     instruction.

     Peephole optimization, which takes place in the last
     jump-optimization pass, can produce insns whose patterns consist
     of a `parallel' whose elements are the operands needed to output
     the resulting assembler code--often `reg', `mem' or constant
     expressions.  This would not be well-formed RTL at any other
     stage in compilation, but it is ok then because no further
     optimization remains to be done.  However, the definition of the
     macro `NOTICE_UPDATE_CC' may need to deal with such insns.

`(sequence [INSNS ...])'
     Represents a sequence of insns.  Each of the INSNS that appears
     in the vector is suitable for appearing in the chain of insns,
     so it must be an `insn', `jump_insn', `call_insn', `code_label',
     `barrier' or `note'.

     A `sequence' RTX never appears in an actual insn.  It represents
     the sequence of insns that result from a `define_expand'
     *before* those insns are passed to `emit_insn' to insert them in
     the chain of insns.  When actually inserted, the individual
     sub-insns are separated out and the `sequence' is forgotten.

Three expression codes appear in place of a side effect, as the body
of an insn, though strictly speaking they do not describe side
effects as such:

`(asm_input S)'
     Represents literal assembler code as described by the string S.

`(addr_vec:M [LR0 LR1 ...])'
     Represents a table of jump addresses.  The vector elements LR0,
     etc., are `label_ref' expressions.  The mode M specifies how
     much space is given to each address; normally M would be `Pmode'.

`(addr_diff_vec:M BASE [LR0 LR1 ...])'
     Represents a table of jump addresses expressed as offsets from
     BASE.  The vector elements LR0, etc., are `label_ref'
     expressions and so is BASE.  The mode M specifies how much space
     is given to each address-difference.



File: gcc.info,  Node: Incdec,  Next: Assembler,  Prev: Side Effects,  Up: RTL

Embedded Side-Effects on Addresses
==================================

Four special side-effect expression codes appear as memory addresses.

`(pre_dec:M X)'
     Represents the side effect of decrementing X by a standard
     amount and represents also the value that X has after being
     decremented.  X must be a `reg' or `mem', but most machines
     allow only a `reg'.  M must be the machine mode for pointers on
     the machine in use.  The amount X is decremented by is the
     length in bytes of the machine mode of the containing memory
     reference of which this expression serves as the address.  Here
     is an example of its use:

          (mem:DF (pre_dec:SI (reg:SI 39)))

     This says to decrement pseudo register 39 by the length of a
     `DFmode' value and use the result to address a `DFmode' value.

`(pre_inc:M X)'
     Similar, but specifies incrementing X instead of decrementing it.

`(post_dec:M X)'
     Represents the same side effect as `pre_decrement' but a
     different value.  The value represented here is the value X has
     before being decremented.

`(post_inc:M X)'
     Similar, but specifies incrementing X instead of decrementing it.

These embedded side effect expressions must be used with care. 
Instruction patterns may not use them.  Until the `flow' pass of the
compiler, they may occur only to represent pushes onto the stack. 
The `flow' pass finds cases where registers are incremented or
decremented in one instruction and used as an address shortly before
or after; these cases are then transformed to use pre- or
post-increment or -decrement.

Explicit popping of the stack could be represented with these
embedded side effect operators, but that would not be safe; the
instruction combination pass could move the popping past pushes, thus
changing the meaning of the code.

An instruction that can be represented with an embedded side effect
could also be represented using `parallel' containing an additional
`set' to describe how the address register is altered.  This is not
done because machines that allow these operations at all typically
allow them wherever a memory address is called for.  Describing them
as additional parallel stores would require doubling the number of
entries in the machine description.



File: gcc.info,  Node: Assembler,  Next: Insns,  Prev: IncDec,  Up: RTL

Assembler Instructions as Expressions
=====================================

The RTX code `asm_operands' represents a value produced by a
user-specified assembler instruction.  It is used to represent an
`asm' statement with arguments.  An `asm' statement with a single
output operand, like this:

     asm ("foo %1,%2,%0" : "a" (outputvar) : "g" (x + y), "di" (*z));

is represented using a single `asm_operands' RTX which represents the
value that is stored in `outputvar':

     (set RTX-FOR-OUTPUTVAR
          (asm_operands "foo %1,%2,%0" "a" 0
                        [RTX-FOR-ADDITION-RESULT RTX-FOR-*Z]
                        [(asm_input:M1 "g")
                         (asm_input:M2 "di")]))

Here the operands of the `asm_operands' RTX are the assembler
template string, the output-operand's constraint, the index-number of
the output operand among the output operands specified, a vector of
input operand RTX's, and a vector of input-operand modes and
constraints.  The mode M1 is the mode of the sum `x+y'; M2 is that of
`*z'.

When an `asm' statement has multiple output values, its insn has
several such `set' RTX's inside of a `parallel'.  Each `set' contains
a `asm_operands'; all of these share the same assembler template and
vectors, but each contains the constraint for the respective output
operand.  They are also distinguished by the output-operand index
number, which is 0, 1, ... for successive output operands.



File: gcc.info,  Node: Insns,  Next: Calls,  Prev: Assembler,  Up: RTL

Insns
=====

The RTL representation of the code for a function is a doubly-linked
chain of objects called "insns".  Insns are expressions with special
codes that are used for no other purpose.  Some insns are actual
instructions; others represent dispatch tables for `switch'
statements; others represent labels to jump to or various sorts of
declarative information.

In addition to its own specific data, each insn must have a unique
id-number that distinguishes it from all other insns in the current
function, and chain pointers to the preceding and following insns. 
These three fields occupy the same position in every insn,
independent of the expression code of the insn.  They could be
accessed with `XEXP' and `XINT', but instead three special macros are
always used:

`INSN_UID (I)'
     Accesses the unique id of insn I.

`PREV_INSN (I)'
     Accesses the chain pointer to the insn preceding I.  If I is the
     first insn, this is a null pointer.

`NEXT_INSN (I)'
     Accesses the chain pointer to the insn following I.  If I is the
     last insn, this is a null pointer.

The `NEXT_INSN' and `PREV_INSN' pointers must always correspond: if I
is not the first insn,

     NEXT_INSN (PREV_INSN (INSN)) == INSN

is always true.

Every insn has one of the following six expression codes:

`insn'
     The expression code `insn' is used for instructions that do not
     jump and do not do function calls.  Insns with code `insn' have
     four additional fields beyond the three mandatory ones listed
     above.  These four are described in a table below.

`jump_insn'
     The expression code `jump_insn' is used for instructions that
     may jump (or, more generally, may contain `label_ref'
     expressions).  `jump_insn' insns have the same extra fields as
     `insn' insns, accessed in the same way.

`call_insn'
     The expression code `call_insn' is used for instructions that
     may do function calls.  It is important to distinguish these
     instructions because they imply that certain registers and
     memory locations may be altered unpredictably.

     `call_insn' insns have the same extra fields as `insn' insns,
     accessed in the same way.

`code_label'
     A `code_label' insn represents a label that a jump insn can jump
     to.  It contains one special field of data in addition to the
     three standard ones.  It is used to hold the "label number", a
     number that identifies this label uniquely among all the labels
     in the compilation (not just in the current function). 
     Ultimately, the label is represented in the assembler output as
     an assembler label `LN' where N is the label number.

`barrier'
     Barriers are placed in the instruction stream after
     unconditional jump instructions to indicate that the jumps are
     unconditional.  They contain no information beyond the three
     standard fields.

`note'
     `note' insns are used to represent additional debugging and
     declarative information.  They contain two nonstandard fields,
     an integer which is accessed with the macro `NOTE_LINE_NUMBER'
     and a string accessed with `NOTE_SOURCE_FILE'.

     If `NOTE_LINE_NUMBER' is positive, the note represents the
     position of a source line and `NOTE_SOURCE_FILE' is the source
     file name that the line came from.  These notes control
     generation of line number data in the assembler output.

     Otherwise, `NOTE_LINE_NUMBER' is not really a line number but a
     code with one of the following values (and `NOTE_SOURCE_FILE'
     must contain a null pointer):

    `NOTE_INSN_DELETED'
          Such a note is completely ignorable.  Some passes of the
          compiler delete insns by altering them into notes of this
          kind.

    `NOTE_INSN_BLOCK_BEG'
    `NOTE_INSN_BLOCK_END'
          These types of notes indicate the position of the beginning
          and end of a level of scoping of variable names.  They
          control the output of debugging information.

    `NOTE_INSN_LOOP_BEG'
    `NOTE_INSN_LOOP_END'
          These types of notes indicate the position of the beginning
          and end of a `while' or `for' loop.  They enable the loop
          optimizer to find loops quickly.

Here is a table of the extra fields of `insn', `jump_insn' and
`call_insn' insns:

`PATTERN (I)'
     An expression for the side effect performed by this insn.

`REG_NOTES (I)'
     A list (chain of `expr_list' expressions) giving information
     about the usage of registers in this insn.  This list is set up
     by the flow analysis pass; it is a null pointer until then.

`LOG_LINKS (I)'
     A list (chain of `insn_list' expressions) of previous
     ``related'' insns: insns which store into registers values that
     are used for the first time in this insn.  (An additional
     constraint is that neither a jump nor a label may come between
     the related insns).  This list is set up by the flow analysis
     pass; it is a null pointer until then.

`INSN_CODE (I)'
     An integer that says which pattern in the machine description
     matches this insn, or -1 if the matching has not yet been
     attempted.

     Such matching is never attempted and this field is not used on
     an insn whose pattern consists of a single `use', `clobber',
     `asm', `addr_vec' or `addr_diff_vec' expression.

The `LOG_LINKS' field of an insn is a chain of `insn_list'
expressions.  Each of these has two operands: the first is an insn,
and the second is another `insn_list' expression (the next one in the
chain).  The last `insn_list' in the chain has a null pointer as
second operand.  The significant thing about the chain is which insns
appear in it (as first operands of `insn_list' expressions).  Their
order is not significant.

The `REG_NOTES' field of an insn is a similar chain but of
`expr_list' expressions instead of `insn_list'.  There are four kinds
of register notes, which are distinguished by the machine mode of the
`expr_list', which a register note is really understood as being an
`enum reg_note'.  The first operand OP of the `expr_list' is data
whose meaning depends on the kind of note.  Here are the four kinds:

`REG_DEAD'
     The register OP dies in this insn; that is to say, altering the
     value immediately after this insn would not affect the future
     behavior of the program.

`REG_INC'
     The register OP is incremented (or decremented; at this level
     there is no distinction) by an embedded side effect inside this
     insn.  This means it appears in a `POST_INC', `PRE_INC',
     `POST_DEC' or `PRE_DEC' RTX.

`REG_EQUIV'
     The register that is set by this insn will be equal to OP at run
     time, and could validly be replaced in all its occurrences by
     OP.  (``Validly'' here refers to the data flow of the program;
     simple replacement may make some insns invalid.)

     The value which the insn explicitly copies into the register may
     look different from OP, but they will be equal at run time.

     For example, when a constant is loaded into a register that is
     never assigned any other value, this kind of note is used.

     When a parameter is copied into a pseudo-register at entry to a
     function, a note of this kind records that the register is
     equivalent to the stack slot where the parameter was passed. 
     Although in this case the register may be set by other insns, it
     is still valid to replace the register by the stack slot
     throughout the function.

`REG_EQUAL'
     The register that is set by this insn will be equal to OP at run
     time at the end of this insn (but not necessarily elsewhere in
     the function).

     The RTX OP is typically an arithmetic expression.  For example,
     when a sequence of insns such as a library call is used to
     perform an arithmetic operation, this kind of note is attached
     to the insn that produces or copies the final value.  It tells
     the CSE pass how to think of that value.

`REG_RETVAL'
     This insn copies the value of a library call, and OP is the
     first insn that was generated to set up the arguments for the
     library call.

     Flow analysis uses this note to delete all of a library call
     whose result is dead.

`REG_WAS_0'
     The register OP contained zero before this insn.  You can rely
     on this note if it is present; its absence implies nothing.

`REG_LIBCALL'
     This is the inverse of `REG_RETVAL': it is placed on the first
     insn of a library call, and it points to the last one.

     Loop optimization uses this note to move an entire library call
     out of a loop when its value is constant.

`REG_NONNEG'
     The register OP is known to have nonnegative value when this
     insn is reached.

(The only difference between the expression codes `insn_list' and
`expr_list' is that the first operand of an `insn_list' is assumed to
be an insn and is printed in debugging dumps as the insn's unique id;
the first operand of an `expr_list' is printed in the ordinary way as
an expression.)



File: gcc.info,  Node: Calls,  Next: Sharing,  Prev: Insns,  Up: RTL

RTL Representation of Function-Call Insns
=========================================

Insns that call subroutines have the RTL expression code `call_insn'.
These insns must satisfy special rules, and their bodies must use a
special RTL expression code, `call'.

A `call' expression has two operands, as follows:

     (call NBYTES (mem:FM ADDR))

Here NBYTES is an operand that represents the number of bytes of
argument data being passed to the subroutine, FM is a machine mode
(which must equal as the definition of the `FUNCTION_MODE' macro in
the machine description) and ADDR represents the address of the
subroutine.

For a subroutine that returns no value, the `call' RTX as shown above
is the entire body of the insn.

For a subroutine that returns a value whose mode is not `BLKmode',
the value is returned in a hard register.  If this register's number
is R, then the body of the call insn looks like this:

     (set (reg:M R)
          (call NBYTES (mem:FM ADDR)))

This RTL expression makes it clear (to the optimizer passes) that the
appropriate register receives a useful value in this insn.

Immediately after RTL generation, if the value of the subroutine is
actually used, this call insn is always followed closely by an insn
which refers to the register R.  This remains true through all the
optimizer passes until cross jumping occurs.

The following insn has one of two forms.  Either it copies the value
into a pseudo-register, like this:

     (set (reg:M P) (reg:M R))

or (in the case where the calling function will simply return
whatever value the call produced, and no operation is needed to do
this):

     (use (reg:M R))

Between the call insn and this following insn there may intervene
only a stack-adjustment insn (and perhaps some `note' insns).

When a subroutine returns a `BLKmode' value, it is handled by passing
to the subroutine the address of a place to store the value.  So the
call insn itself does not ``return'' any value, and it has the same
RTL form as a call that returns nothing.



File: gcc.info,  Node: Sharing,  Prev: Calls,  Up: RTL

Structure Sharing Assumptions
=============================

The compiler assumes that certain kinds of RTL expressions are
unique; there do not exist two distinct objects representing the same
value.  In other cases, it makes an opposite assumption: that no RTL
expression object of a certain kind appears in more than one place in
the containing structure.

These assumptions refer to a single function; except for the RTL
objects that describe global variables and external functions, no RTL
objects are common to two functions.

   * Each pseudo-register has only a single `reg' object to represent
     it, and therefore only a single machine mode.

   * For any symbolic label, there is only one `symbol_ref' object
     referring to it.

   * There is only one `const_int' expression with value zero, and
     only one with value one.

   * There is only one `pc' expression.

   * There is only one `cc0' expression.

   * There is only one `const_double' expression with mode `SFmode'
     and value zero, and only one with mode `DFmode' and value zero.

   * No `label_ref' appears in more than one place in the RTL
     structure; in other words, it is safe to do a tree-walk of all
     the insns in the function and assume that each time a
     `label_ref' is seen it is distinct from all others that are seen.

   * Only one `mem' object is normally created for each static
     variable or stack slot, so these objects are frequently shared
     in all the places they appear.  However, separate but equal
     objects for these variables are occasionally made.

   * No RTL object appears in more than one place in the RTL
     structure except as described above.  Many passes of the
     compiler rely on this by assuming that they can modify RTL
     objects in place without unwanted side-effects on other insns.

   * During initial RTL generation, shared structure is freely
     introduced.  After all the RTL for a function has been
     generated, all shared structure is copied by `unshare_all_rtl'
     in `emit-rtl.c', after which the above rules are guaranteed to
     be followed.

   * During the combiner pass, shared structure with an insn can
     exist temporarily.  However, the shared structure is copied
     before the combiner is finished with the insn.  This is done by
     `copy_substitutions' in `combine.c'.



File: gcc.info,  Node: Machine Desc,  Next: Machine Macros,  Prev: RTL,  Up: Top

Machine Descriptions
********************

A machine description has two parts: a file of instruction patterns
(`.md' file) and a C header file of macro definitions.

The `.md' file for a target machine contains a pattern for each
instruction that the target machine supports (or at least each
instruction that is worth telling the compiler about).  It may also
contain comments.  A semicolon causes the rest of the line to be a
comment, unless the semicolon is inside a quoted string.

See the next chapter for information on the C header file.

* Menu:

* Patterns::            How to write instruction patterns.
* Example::             An explained example of a `define_insn' pattern.
* RTL Template::        The RTL template defines what insns match a pattern.
* Output Template::     The output template says how to make assembler code
                          from such an insn.
* Output Statement::    For more generality, write C code to output 
                          the assembler code.
* Constraints::         When not all operands are general operands.
* Standard Names::      Names mark patterns to use for code generation.
* Pattern Ordering::    When the order of patterns makes a difference.
* Dependent Patterns::  Having one pattern may make you need another.
* Jump Patterns::       Special considerations for patterns for jump insns.
* Peephole Definitions::Defining machine-specific peephole optimizations.
* Expander Definitions::Generating a sequence of several RTL insns
                         for a standard operation.

 

File: gcc.info,  Node: Patterns,  Next: Example,  Prev: Machine Desc,  Up: Machine Desc

Everything about Instruction Patterns
=====================================

Each instruction pattern contains an incomplete RTL expression, with
pieces to be filled in later, operand constraints that restrict how
the pieces can be filled in, and an output pattern or C code to
generate the assembler output, all wrapped up in a `define_insn'
expression.

A `define_insn' is an RTL expression containing four or five operands:

  1. An optional name.  The presence of a name indicate that this
     instruction pattern can perform a certain standard job for the
     RTL-generation pass of the compiler.  This pass knows certain
     names and will use the instruction patterns with those names, if
     the names are defined in the machine description.

     The absence of a name is indicated by writing an empty string
     where the name should go.  Nameless instruction patterns are
     never used for generating RTL code, but they may permit several
     simpler insns to be combined later on.

     Names that are not thus known and used in RTL-generation have no
     effect; they are equivalent to no name at all.

  2. The "RTL template" (*note RTL Template::.) is a vector of
     incomplete RTL expressions which show what the instruction
     should look like.  It is incomplete because it may contain
     `match_operand' and `match_dup' expressions that stand for
     operands of the instruction.

     If the vector has only one element, that element is what the
     instruction should look like.  If the vector has multiple
     elements, then the instruction looks like a `parallel'
     expression containing that many elements as described.

  3. A condition.  This is a string which contains a C expression
     that is the final test to decide whether an insn body matches
     this pattern.

     For a named pattern, the condition (if present) may not depend
     on the data in the insn being matched, but only the
     target-machine-type flags.  The compiler needs to test these
     conditions during initialization in order to learn exactly which
     named instructions are available in a particular run.

     For nameless patterns, the condition is applied only when
     matching an individual insn, and only after the insn has matched
     the pattern's recognition template.  The insn's operands may be
     found in the vector `operands'.

  4. The "output template": a string that says how to output matching
     insns as assembler code.  `%' in this string specifies where to
     substitute the value of an operand.  *Note Output Template::.

     When simple substitution isn't general enough, you can specify a
     piece of C code to compute the output.  *Note Output Statement::.

  5. Optionally, some "machine-specific information".  The meaning of
     this information is defined only by an individual machine
     description; typically it might say whether this insn alters the
     condition codes, or how many bytes of output it generates.

     This operand is written as a string containing a C initializer
     (complete with braces) for the structure type
     `INSN_MACHINE_INFO', whose definition is up to you (*note
     Misc::.).



File: gcc.info,  Node: Example,  Next: RTL Template,  Prev: Patterns,  Up: Machine Desc

Example of `define_insn'
========================

Here is an actual example of an instruction pattern, for the
68000/68020.

     (define_insn "tstsi"
       [(set (cc0)
             (match_operand:SI 0 "general_operand" "rm"))]
       ""
       "*
     { if (TARGET_68020 || ! ADDRESS_REG_P (operands[0]))
         return \"tstl %0\";
       return \"cmpl #0,%0\"; }")

This is an instruction that sets the condition codes based on the
value of a general operand.  It has no condition, so any insn whose
RTL description has the form shown may be handled according to this
pattern.  The name `tstsi' means ``test a `SImode' value'' and tells
the RTL generation pass that, when it is necessary to test such a
value, an insn to do so can be constructed using this pattern.

The output control string is a piece of C code which chooses which
output template to return based on the kind of operand and the
specific type of CPU for which code is being generated.

`"rm"' is an operand constraint.  Its meaning is explained below.



File: gcc.info,  Node: RTL Template,  Next: Output Template,  Prev: Example,  Up: Machine Desc

RTL Template for Generating and Recognizing Insns
=================================================

The RTL template is used to define which insns match the particular
pattern and how to find their operands.  For named patterns, the RTL
template also says how to construct an insn from specified operands.

Construction involves substituting specified operands into a copy of
the template.  Matching involves determining the values that serve as
the operands in the insn being matched.  Both of these activities are
controlled by special expression types that direct matching and
substitution of the operands.

`(match_operand:M N TESTFN CONSTRAINT)'
     This expression is a placeholder for operand number N of the
     insn.  When constructing an insn, operand number N will be
     substituted at this point.  When matching an insn, whatever
     appears at this position in the insn will be taken as operand
     number N; but it must satisfy TESTFN or this instruction pattern
     will not match at all.

     Operand numbers must be chosen consecutively counting from zero
     in each instruction pattern.  There may be only one
     `match_operand' expression in the pattern for each operand
     number.  Usually operands are numbered in the order of
     appearance in `match_operand' expressions.

     TESTFN is a string that is the name of a C function that accepts
     two arguments, a machine mode and an expression.  During
     matching, the function will be called with M as the mode
     argument and the putative operand as the other argument.  If it
     returns zero, this instruction pattern fails to match.  TESTFN
     may be an empty string; then it means no test is to be done on
     the operand.

     CONSTRAINT is explained later (*note Constraints::.).

     Most often, TESTFN is `"general_operand"'.  It checks that the
     putative operand is either a constant, a register or a memory
     reference, and that it is valid for mode M.

     For an operand that must be a register, TESTFN should be
     `"register_operand"'.  It would be valid to use
     `"general_operand"', since the reload pass would copy any
     non-register operands through registers, but this would make GNU
     CC do extra work, and it would prevent the register allocator
     from doing the best possible job.

     For an operand that must be a constant, either TESTFN should be
     `"immediate_operand"', or the instruction pattern's extra
     condition should check for constants, or both.  You cannot
     expect the constraints to do this work!  If the constraints
     allow only constants, but the predicate allows something else,
     the compiler will crash when that case arises.

`(match_dup N)'
     This expression is also a placeholder for operand number N.  It
     is used when the operand needs to appear more than once in the
     insn.

     In construction, `match_dup' behaves exactly like
     `match_operand': the operand is substituted into the insn being
     constructed.  But in matching, `match_dup' behaves differently. 
     It assumes that operand number N has already been determined by
     a `match_operand' appearing earlier in the recognition template,
     and it matches only an identical-looking expression.

`(address (match_operand:M N "address_operand" ""))'
     This complex of expressions is a placeholder for an operand
     number N in a ``load address'' instruction: an operand which
     specifies a memory location in the usual way, but for which the
     actual operand value used is the address of the location, not
     the contents of the location.

     `address' expressions never appear in RTL code, only in machine
     descriptions.  And they are used only in machine descriptions
     that do not use the operand constraint feature.  When operand
     constraints are in use, the letter `p' in the constraint serves
     this purpose.

     M is the machine mode of the *memory location being addressed*,
     not the machine mode of the address itself.  That mode is always
     the same on a given target machine (it is `Pmode', which
     normally is `SImode'), so there is no point in mentioning it;
     thus, no machine mode is written in the `address' expression. 
     If some day support is added for machines in which addresses of
     different kinds of objects appear differently or are used
     differently (such as the PDP-10), different formats would
     perhaps need different machine modes and these modes might be
     written in the `address' expression.



File: gcc.info,  Node: Output Template,  Next: Output Statement,  Prev: RTL Template,  Up: Machine Desc

Output Templates and Operand Substitution
=========================================

The "output template" is a string which specifies how to output the
assembler code for an instruction pattern.  Most of the template is a
fixed string which is output literally.  The character `%' is used to
specify where to substitute an operand; it can also be used to
identify places different variants of the assembler require different
syntax.

In the simplest case, a `%' followed by a digit N says to output
operand N at that point in the string.

`%' followed by a letter and a digit says to output an operand in an
alternate fashion.  Four letters have standard, built-in meanings
described below.  The machine description macro `PRINT_OPERAND' can
define additional letters with nonstandard meanings.

`%cDIGIT' can be used to substitute an operand that is a constant
value without the syntax that normally indicates an immediate operand.

`%nDIGIT' is like `%cDIGIT' except that the value of the constant is
negated before printing.

`%aDIGIT' can be used to substitute an operand as if it were a memory
reference, with the actual operand treated as the address.  This may
be useful when outputting a ``load address'' instruction, because
often the assembler syntax for such an instruction requires you to
write the operand as if it were a memory reference.

`%lDIGIT' is used to substitute a `label_ref' into a jump instruction.

`%' followed by a punctuation character specifies a substitution that
does not use an operand.  Only one case is standard: `%%' outputs a
`%' into the assembler code.  Other nonstandard cases can be defined
in the `PRINT_OPERAND' macro.

The template may generate multiple assembler instructions.  Write the
text for the instructions, with `\;' between them.

When the RTL contains two operand which are required by constraint to
match each other, the output template must refer only to the
lower-numbered operand.  Matching operands are not always identical,
and the rest of the compiler arranges to put the proper RTL
expression for printing into the lower-numbered operand.

One use of nonstandard letters or punctuation following `%' is to
distinguish between different assembler languages for the same
machine; for example, Motorola syntax versus MIT syntax for the
68000.  Motorola syntax requires periods in most opcode names, while
MIT syntax does not.  For example, the opcode `movel' in MIT syntax
is `move.l' in Motorola syntax.  The same file of patterns is used
for both kinds of output syntax, but the character sequence `%.' is
used in each place where Motorola syntax wants a period.  The
`PRINT_OPERAND' macro for Motorola syntax defines the sequence to
output a period; the macro for MIT syntax defines it to do nothing.



File: gcc.info,  Node: Output Statement,  Next: Constraints,  Prev: Output Template,  Up: Machine Desc

C Statements for Generating Assembler Output
============================================

Often a single fixed template string cannot produce correct and
efficient assembler code for all the cases that are recognized by a
single instruction pattern.  For example, the opcodes may depend on
the kinds of operands; or some unfortunate combinations of operands
may require extra machine instructions.

If the output control string starts with a `*', then it is not an
output template but rather a piece of C program that should compute a
template.  It should execute a `return' statement to return the
template-string you want.  Most such templates use C string literals,
which require doublequote characters to delimit them.  To include
these doublequote characters in the string, prefix each one with `\'.

The operands may be found in the array `operands', whose C data type
is `rtx []'.

It is possible to output an assembler instruction and then go on to
output or compute more of them, using the subroutine
`output_asm_insn'.  This receives two arguments: a template-string
and a vector of operands.  The vector may be `operands', or it may be
another array of `rtx' that you declare locally and initialize
yourself.

When an insn pattern has multiple alternatives in its constraints,
often the appearance of the assembler code determined mostly by which
alternative was matched.  When this is so, the C code can test the
variable `which_alternative', which is the ordinal number of the
alternative that was actually satisfied (0 for the first, 1 for the
second alternative, etc.).

For example, suppose there are two opcodes for storing zero, `clrreg'
for registers and `clrmem' for memory locations.  Here is how a
pattern could use `which_alternative' to choose between them:

     (define_insn ""
       [(set (match_operand:SI 0 "general_operand" "r,m")
             (const_int 0))]
       ""
       "*
       return (which_alternative == 0
               ? \"clrreg %0\" : \"clrmem %0\");
       ")



File: gcc.info,  Node: Constraints,  Next: Standard Names,  Prev: Output Statement,  Up: Machine Desc

Operand Constraints
===================

Each `match_operand' in an instruction pattern can specify a
constraint for the type of operands allowed.  Constraints can say
whether an operand may be in a register, and which kinds of register;
whether the operand can be a memory reference, and which kinds of
address; whether the operand may be an immediate constant, and which
possible values it may have.  Constraints can also require two
operands to match.

* Menu:

* Simple Constraints::  Basic use of constraints.
* Multi-Alternative::   When an insn has two alternative constraint-patterns.
* Class Preferences::   Constraints guide which hard register to put things in.
* Modifiers::           More precise control over effects of constraints.
* No Constraints::      Describing a clean machine without constraints.

 