Info file gcc.info, produced by Makeinfo, -*- Text -*- from input
file gcc.texinfo.

This file documents the use and the internals of the GNU compiler.

Copyright (C) 1988 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled ``GNU CC General Public License'' is
included exactly as in the original, and provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled ``GNU CC General Public
License'' and this permission notice may be included in translations
approved by the Free Software Foundation instead of in the original
English.

 

File: gcc.info,  Node: Simple Constraints,  Next: Multi-Alternative,  Prev: Constraints,  Up: Constraints

Simple Constraints
------------------

The simplest kind of constraint is a string full of letters, each of
which describes one kind of operand that is permitted.  Here are the
letters that are allowed:

`m'
     A memory operand is allowed, with any kind of address that the
     machine supports in general.

`o'
     A memory operand is allowed, but only if the address is
     "offsetable".  This means that adding a small integer (actually,
     the width in bytes of the operand, as determined by its machine
     mode) may be added to the address and the result is also a valid
     memory address.

     For example, an address which is constant is offsetable; so is
     an address that is the sum of a register and a constant (as long
     as a slightly larger constant is also within the range of
     address-offsets supported by the machine); but an autoincrement
     or autodecrement address is not offsetable.  More complicated
     indirect/indexed addresses may or may not be offsetable
     depending on the other addressing modes that the machine supports.

     Note that in an output operand which can be matched by another
     operand, the constraint letter `o' is valid only when
     accompanied by both `<' (if the target machine has predecrement
     addressing) and `>' (if the target machine has preincrement
     addressing).

     When the constraint letter `o' is used, the reload pass may
     generate instructions which copy a nonoffsetable address into an
     index register.  The idea is that the register can be used as a
     replacement offsetable address.  But this method requires that
     there be patterns to copy any kind of address into a register. 
     Auto-increment and auto-decrement addresses are an exception;
     there need not be an instruction that can copy such an address
     into a register, because reload handles these cases specially.

     Most older machine designs have ``load address'' instructions
     which do just what is needed here.  Some RISC machines do not
     advertise such instructions, but the possible addresses on these
     machines are very limited, so it is easy to fake them.

`<'
     A memory operand with autodecrement addressing (either
     predecrement or postdecrement) is allowed.

`>'
     A memory operand with autoincrement addressing (either
     preincrement or postincrement) is allowed.

`r'
     A register operand is allowed provided that it is in a general
     register.

`d', `a', `f', ...
      Other letters can be defined in machine-dependent fashion to
     stand for particular classes of registers.  `d', `a' and `f' are
     defined on the 68000/68020 to stand for data, address and
     floating point registers.

`i'
     An immediate integer operand (one with constant value) is allowed.
     This includes symbolic constants whose values will be known only
     at assembly time.

`n'
     An immediate integer operand with a known numeric value is
     allowed.  Many systems cannot support assembly-time constants
     for operands less than a word wide.  Constraints for these
     operands should use `n' rather than `i'.

`I', `J', `K', ...
      Other letters in the range `I' through `M' may be defined in a
     machine-dependent fashion to permit immediate integer operands
     with explicit integer values in specified ranges.  For example,
     on the 68000, `I' is defined to stand for the range of values 1
     to 8.  This is the range permitted as a shift count in the shift
     instructions.

`F'
     An immediate floating operand (expression code `const_double')
     is allowed.

`G', `H'
     `G' and `H' may be defined in a machine-dependent fashion to
     permit immediate floating operands in particular ranges of values.

`s'
     An immediate integer operand whose value is not an explicit
     integer is allowed.

     This might appear strange; if an insn allows a constant operand
     with a value not known at compile time, it certainly must allow
     any known value.  So why use `s' instead of `i'?  Sometimes it
     allows better code to be generated.

     For example, on the 68000 in a fullword instruction it is
     possible to use an immediate operand; but if the immediate value
     is between -32 and 31, better code results from loading the
     value into a register and using the register.  This is because
     the load into the register can be done with a `moveq'
     instruction.  We arrange for this to happen by defining the
     letter `K' to mean ``any integer outside the range -32 to 31'',
     and then specifying `Ks' in the operand constraints.

`g'
     Any register, memory or immediate integer operand is allowed,
     except for registers that are not general registers.

`N' (a digit)
     An operand that matches operand number N is allowed.  If a digit
     is used together with letters, the digit should come last.

     This is called a "matching constraint" and what it really means
     is that the assembler has only a single operand that fills two
     roles considered separate in the RTL insn.  For example, an add
     insn has two input operands and one output operand in the RTL,
     but on most machines an add instruction really has only two
     operands, one of them an input-output operand.

     Matching constraints work only in circumstances like that add
     insn.  More precisely, the matching constraint must appear in an
     input-only operand and the operand that it matches must be an
     output-only operand with a lower number.

     For operands to match in a particular case usually means that
     they are identical-looking RTL expressions.  But in a few
     special cases specific kinds of dissimilarity are allowed.  For
     example, `*x' as an input operand will match `*x++' as an output
     operand.  For proper results in such cases, the output template
     should always use the output-operand's number when printing the
     operand.

`p'
     An operand that is a valid memory address is allowed.  This is
     for ``load address'' and ``push address'' instructions.

     If `p' is used in the constraint, the test-function in the
     `match_operand' must be `address_operand'.

In order to have valid assembler code, each operand must satisfy its
constraint.  But a failure to do so does not prevent the pattern from
applying to an insn.  Instead, it directs the compiler to modify the
code so that the constraint will be satisfied.  Usually this is done
by copying an operand into a register.

Contrast, therefore, the two instruction patterns that follow:

     (define_insn ""
       [(set (match_operand:SI 0 "general_operand" "r")
             (plus:SI (match_dup 0)
                      (match_operand:SI 1 "general_operand" "r")))]
       ""
       "...")

which has two operands, one of which must appear in two places, and

     (define_insn ""
       [(set (match_operand:SI 0 "general_operand" "r")
             (plus:SI (match_operand:SI 1 "general_operand" "0")
                      (match_operand:SI 2 "general_operand" "r")))]
       ""
       "...")

which has three operands, two of which are required by a constraint
to be identical.  If we are considering an insn of the form

     (insn N PREV NEXT
       (set (reg:SI 3)
            (plus:SI (reg:SI 6) (reg:SI 109)))
       ...)

the first pattern would not apply at all, because this insn does not
contain two identical subexpressions in the right place.  The pattern
would say, ``That does not look like an add instruction; try other
patterns.'' The second pattern would say, ``Yes, that's an add
instruction, but there is something wrong with it.''  It would direct
the reload pass of the compiler to generate additional insns to make
the constraint true.  The results might look like this:

     (insn N2 PREV N
       (set (reg:SI 3) (reg:SI 6))
       ...)
     
     (insn N N2 NEXT
       (set (reg:SI 3)
            (plus:SI (reg:SI 3) (reg:SI 109)))
       ...)

It is up to you to make sure that each operand, in each pattern, has
constraints that can handle any RTL expression that could be present
for that operand.  (When multiple alternatives are in use, each
pattern must, for each possible combination of operand expressions,
have at least one alternative which can handle that combination of
operands.)  The constraints don't need to *allow* any possible
operand--when this is the case, they do not constrain--but they must
at least point the way to reloading any possible operand so that it
will fit.

   * If the constraint accepts whatever operands the predicate
     permits, there is no problem: reloading is never necessary for
     this operand.

     For example, an operand whose constraints permit everything
     except registers is safe provided its predicate rejects registers.

     An operand whose predicate accepts only constant values is safe
     provided its constraints include the letter `i'.  If any
     possible constant value is accepted, then nothing less than `i'
     will do; if the predicate is more selective, than the
     constraints may also be more selective.

   * Any operand expression can be reloaded by copying it into a
     register.  So if an operand's constraints allow some kind of
     register, it is certain to be safe.  It need not permit all
     classes of registers; the compiler knows how to copy a register
     into another register of the proper class in order to make an
     instruction valid.

   * A nonoffsetable memory reference can be reloaded by copying the
     address into a register.  So if the constraint uses the letter
     `o', all memory references are taken care of.

   * A constant operand can be reloaded by storing it in memory; it
     then becomes an offsetable memory reference.  So if the
     constraint uses the letters `o' or `m', constant operands are
     not a problem.

If the operand's predicate can recognize registers, but the
constraint does not permit them, it can make the compiler crash. 
When this operand happens to be a register, the reload pass will be
stymied, because it does not know how to copy a register temporarily
into memory.



File: gcc.info,  Node: Multi-Alternative,  Next: Class Preferences,  Prev: Simple Constraints,  Up: Constraints

Multiple Alternative Constraints
--------------------------------

Sometimes a single instruction has multiple alternative sets of
possible operands.  For example, on the 68000, a logical-or
instruction can combine register or an immediate value into memory,
or it can combine any kind of operand into a register; but it cannot
combine one memory location into another.

These constraints are represented as multiple alternatives.  An
alternative can be described by a series of letters for each operand.
The overall constraint for an operand is made from the letters for
this operand from the first alternative, a comma, the letters for
this operand from the second alternative, a comma, and so on until
the last alternative.  Here is how it is done for fullword logical-or
on the 68000:

     (define_insn "iorsi3"
       [(set (match_operand:SI 0 "general_operand" "=%m,d")
             (ior:SI (match_operand:SI 1 "general_operand" "0,0")
                     (match_operand:SI 2 "general_operand" "dKs,dmKs")))]
       ...)

The first alternative has `m' (memory) for operand 0, `0' for operand
1 (meaning it must match operand 0), and `dKs' for operand 2.  The
second alternative has `d' (data register) for operand 0, `0' for
operand 1, and `dmKs' for operand 2.  The `=' and `%' in the
constraint for operand 0 are not part of any alternative; their
meaning is explained in the next section.

If all the operands fit any one alternative, the instruction is valid.
Otherwise, for each alternative, the compiler counts how many
instructions must be added to copy the operands so that that
alternative applies.  The alternative requiring the least copying is
chosen.  If two alternatives need the same amount of copying, the one
that comes first is chosen.  These choices can be altered with the
`?' and `!' characters:

`?'
     Disparage slightly the alternative that the `?' appears in, as a
     choice when no alternative applies exactly.  The compiler
     regards this alternative as one unit more costly for each `?'
     that appears in it.

`!'
     Disparage severely the alternative that the `!' appears in. 
     When operands must be copied into registers, the compiler will
     never choose this alternative as the one to strive for.

When an insn pattern has multiple alternatives in its constraints,
often the appearance of the assembler code determined mostly by which
alternative was matched.  When this is so, the C code for writing the
assembler code can use the variable `which_alternative', which is the
ordinal number of the alternative that was actually satisfied (0 for
the first, 1 for the second alternative, etc.).  For example:

     (define_insn ""
       [(set (match_operand:SI 0 "general_operand" "r,m")
             (const_int 0))]
       ""
       "*
       return (which_alternative == 0
               ? \"clrreg %0\" : \"clrmem %0\");
       ")



File: gcc.info,  Node: Class Preferences,  Next: Modifiers,  Prev: Multi-Alternative,  Up: Constraints

Register Class Preferences
--------------------------

The operand constraints have another function: they enable the
compiler to decide which kind of hardware register a pseudo register
is best allocated to.  The compiler examines the constraints that
apply to the insns that use the pseudo register, looking for the
machine-dependent letters such as `d' and `a' that specify classes of
registers.  The pseudo register is put in whichever class gets the
most ``votes''.  The constraint letters `g' and `r' also vote: they
vote in favor of a general register.  The machine description says
which registers are considered general.

Of course, on some machines all registers are equivalent, and no
register classes are defined.  Then none of this complexity is
relevant.



File: gcc.info,  Node: Modifiers,  Next: No Constraints,  Prev: Class Preferences,  Up: Constraints

Constraint Modifier Characters
------------------------------

`='
     Means that this operand is write-only for this instruction: the
     previous value is discarded and replaced by output data.

`+'
     Means that this operand is both read and written by the
     instruction.

     When the compiler fixes up the operands to satisfy the
     constraints, it needs to know which operands are inputs to the
     instruction and which are outputs from it.  `=' identifies an
     output; `+' identifies an operand that is both input and output;
     all other operands are assumed to be input only.

`&'
     Means (in a particular alternative) that this operand is written
     before the instruction is finished using the input operands. 
     Therefore, this operand may not lie in a register that is used
     as an input operand or as part of any memory address.

     `&' applies only to the alternative in which it is written.  In
     constraints with multiple alternatives, sometimes one
     alternative requires `&' while others do not.  See, for example,
     the `movdf' insn of the 68000.

     `&' does not obviate the need to write `='.

`%'
     Declares the instruction to be commutative for this operand and
     the following operand.  This means that the compiler may
     interchange the two operands if that is the cheapest way to make
     all operands fit the constraints.  This is often used in
     patterns for addition instructions that really have only two
     operands: the result must go in one of the arguments.  Here for
     example, is how the 68000 halfword-add instruction is defined:

          (define_insn "addhi3"
            [(set (match_operand:HI 0 "general_operand" "=m,r")
               (plus:HI (match_operand:HI 1 "general_operand" "%0,0")
                        (match_operand:HI 2 "general_operand" "di,g")))]
            ...)

     Note that in previous versions of GNU CC the `%' constraint
     modifier always applied to operands 1 and 2 regardless of which
     operand it was written in.  The usual custom was to write it in
     operand 0.  Now it must be in operand 1 if the operands to be
     exchanged are 1 and 2.

`#'
     Says that all following characters, up to the next comma, are to
     be ignored as a constraint.  They are significant only for
     choosing register preferences.

`*'
     Says that the following character should be ignored when
     choosing register preferences.  `*' has no effect on the meaning
     of the constraint as a constraint.

     Here is an example: the 68000 has an instruction to sign-extend
     a halfword in a data register, and can also sign-extend a value
     by copying it into an address register.  While either kind of
     register is acceptable, the constraints on an address-register
     destination are less strict, so it is best if register
     allocation makes an address register its goal.  Therefore, `*'
     is used so that the `d' constraint letter (for data register) is
     ignored when computing register preferences.

          (define_insn "extendhisi2"
            [(set (match_operand:SI 0 "general_operand" "=*d,a")
                  (sign_extend:SI
                   (match_operand:HI 1 "general_operand" "0,g")))]
            ...)



File: gcc.info,  Node: No Constraints,  Prev: Modifiers,  Up: Constraints

Not Using Constraints
---------------------

Some machines are so clean that operand constraints are not required.
For example, on the Vax, an operand valid in one context is valid in
any other context.  On such a machine, every operand constraint would
be `g', excepting only operands of ``load address'' instructions
which are written as if they referred to a memory location's contents
but actual refer to its address.  They would have constraint `p'.

For such machines, instead of writing `g' and `p' for all the
constraints, you can choose to write a description with empty
constraints.  Then you write `""' for the constraint in every
`match_operand'.  Address operands are identified by writing an
`address' expression around the `match_operand', not by their
constraints.

When the machine description has just empty constraints, certain
parts of compilation are skipped, making the compiler faster.



File: gcc.info,  Node: Standard Names,  Next: Pattern Ordering,  Prev: Constraints,  Up: Machine Desc

Standard Names for Patterns Used in Generation
==============================================

Here is a table of the instruction names that are meaningful in the
RTL generation pass of the compiler.  Giving one of these names to an
instruction pattern tells the RTL generation pass that it can use the
pattern in to accomplish a certain task.

`movM'
     Here M is a two-letter machine mode name, in lower case.  This
     instruction pattern moves data with that machine mode from
     operand 1 to operand 0.  For example, `movsi' moves full-word
     data.

     If operand 0 is a `subreg' with mode M of a register whose
     natural mode is wider than M, the effect of this instruction is
     to store the specified value in the part of the register that
     corresponds to mode M.  The effect on the rest of the register
     is undefined.

     This class of patterns is special in several ways.  First of
     all, each of these names *must* be defined, because there is no
     other way to copy a datum from one place to another.

     Second, these patterns are not used solely in the RTL generation
     pass.  Even the reload pass can generate move insns to copy
     values from stack slots into temporary registers.  When it does
     so, one of the operands is a hard register and the other is an
     operand that can have a reload.

     Therefore, when given such a pair of operands, the pattern must
     generate RTL which needs no temporary registers--no registers
     other than the operands.  For example, if you support the
     pattern with a `define_expand', then in such a case you mustn't
     call `force_reg' or any other such function which might generate
     new pseudo registers.

     This requirement exists even for subword modes on a RISC machine
     where fetching those modes from memory normally requires several
     insns and some temporary registers.  Look in `spur.md' to see
     how the requirement is satisfied.

     The variety of operands that have reloads depends on the rest of
     the machine description, but typically on a RISC machine these
     can only be pseudo registers that did not get hard registers,
     while on other machines explicit memory references will get
     optional reloads.

     In addition, the constraints must allow any hard register to be
     moved to any other hard register (provided that
     `HARD_REGNO_MODE_OK' permits mode M in each of the registers).

`movstrictM'
     Like `movM' except that if operand 0 is a `subreg' with mode M
     of a register whose natural mode is wider, the `movstrictM'
     instruction is guaranteed not to alter any of the register
     except the part which belongs to mode M.

`addM3'
     Add operand 2 and operand 1, storing the result in operand 0. 
     All operands must have mode M.  This can be used even on
     two-address machines, by means of constraints requiring operands
     1 and 0 to be the same location.

`subM3', `mulM3', `umulM3', `divM3', `udivM3', `modM3', `umodM3', `andM3', `iorM3', `xorM3'
     Similar, for other arithmetic operations.

     There are special considerations for register classes for
     logical-and instructions, affecting also the macro
     `PREFERRED_RELOAD_CLASS'.  They apply not only to the patterns
     with these standard names, but to any patterns that will match
     such an instruction.  *Note Register Classes::.

`mulhisi3'
     Multiply operands 1 and 2, which have mode `HImode', and store a
     `SImode' product in operand 0.

`mulqihi3', `mulsidi3'
     Similar widening-multiplication instructions of other widths.

`umulqihi3', `umulhisi3', `umulsidi3'
     Similar widening-multiplication instructions that do unsigned
     multiplication.

`divmodM4'
     Signed division that produces both a quotient and a remainder. 
     Operand 1 is divided by operand 2 to produce a quotient stored
     in operand 0 and a remainder stored in operand 3.

`udivmodM4'
     Similar, but does unsigned division.

`divmodMN4'
     Like `divmodM4' except that only the dividend has mode M; the
     divisor, quotient and remainder have mode N.  For example, the
     Vax has a `divmoddisi4' instruction (but it is omitted from the
     machine description, because it is so slow that it is faster to
     compute remainders by the circumlocution that the compiler will
     use if this instruction is not available).

`ashlM3'
     Arithmetic-shift operand 1 left by a number of bits specified by
     operand 2, and store the result in operand 0.  Operand 2 has
     mode `SImode', not mode M.

`ashrM3', `lshlM3', `lshrM3', `rotlM3', `rotrM3'
     Other shift and rotate instructions.

     Logical and arithmetic left shift are the same.  Machines that
     do not allow negative shift counts often have only one
     instruction for shifting left.  On such machines, you should
     define a pattern named `ashlM3' and leave `lshlM3' undefined.

     There are special considerations for register classes for shift
     instructions, affecting also the macro `PREFERRED_RELOAD_CLASS'.
     They apply not only to the patterns with these standard names,
     but to any patterns that will match such an instruction.  *Note
     Register Classes::.

`negM2'
     Negate operand 1 and store the result in operand 0.

`absM2'
     Store the absolute value of operand 1 into operand 0.

`sqrtM2'
     Store the square root of operand 1 into operand 0.

`ffsM2'
     Store into operand 0 one plus the index of the least significant
     1-bit of operand 1.  If operand 1 is zero, store zero.  M is the
     mode of operand 0; operand 1's mode is specified by the
     instruction pattern, and the compiler will convert the operand
     to that mode before generating the instruction.

`one_cmplM2'
     Store the bitwise-complement of operand 1 into operand 0.

`cmpM'
     Compare operand 0 and operand 1, and set the condition codes. 
     The RTL pattern should look like this:

          (set (cc0) (minus (match_operand:M 0 ...)
                            (match_operand:M 1 ...)))

     Each such definition in the machine description, for integer
     mode M, must have a corresponding `tstM' pattern, because
     optimization can simplify the compare into a test when operand 1
     is zero.

`tstM'
     Compare operand 0 against zero, and set the condition codes. 
     The RTL pattern should look like this:

          (set (cc0) (match_operand:M 0 ...))

`movstrM'
     Block move instruction.  The addresses of the destination and
     source strings are the first two operands, and both are in mode
     `Pmode'.  The number of bytes to move is the third operand, in
     mode M.

`cmpstrM'
     Block compare instruction, with operands like `movstrM' except
     that the two memory blocks are compared byte by byte in
     lexicographic order.  The effect of the instruction is to set
     the condition codes.

`floatMN2'
     Convert operand 1 (valid for fixed point mode M) to floating
     point mode N and store in operand 0 (which has mode N).

`fixMN2'
     Convert operand 1 (valid for floating point mode M) to fixed
     point mode N as a signed number and store in operand 0 (which
     has mode N).  This instruction's result is defined only when the
     value of operand 1 is an integer.

`fixunsMN2'
     Convert operand 1 (valid for floating point mode M) to fixed
     point mode N as an unsigned number and store in operand 0 (which
     has mode N).  This instruction's result is defined only when the
     value of operand 1 is an integer.

`ftruncM2'
     Convert operand 1 (valid for floating point mode M) to an
     integer value, still represented in floating point mode M, and
     store it in operand 0 (valid for floating point mode M).

`fix_truncMN2'
     Like `fixMN2' but works for any floating point value of mode M
     by converting the value to an integer.

`fixuns_truncMN2'
     Like `fixunsMN2' but works for any floating point value of mode
     M by converting the value to an integer.

`truncMN'
     Truncate operand 1 (valid for mode M) to mode N and store in
     operand 0 (which has mode N).  Both modes must be fixed point or
     both floating point.

`extendMN'
     Sign-extend operand 1 (valid for mode M) to mode N and store in
     operand 0 (which has mode N).  Both modes must be fixed point or
     both floating point.

`zero_extendMN'
     Zero-extend operand 1 (valid for mode M) to mode N and store in
     operand 0 (which has mode N).  Both modes must be fixed point.

`extv'
     Extract a bit-field from operand 1 (a register or memory
     operand), where operand 2 specifies the width in bits and
     operand 3 the starting bit, and store it in operand 0.  Operand
     0 must have `Simode'.  Operand 1 may have mode `QImode' or
     `SImode'; often `SImode' is allowed only for registers. 
     Operands 2 and 3 must be valid for `SImode'.

     The RTL generation pass generates this instruction only with
     constants for operands 2 and 3.

     The bit-field value is sign-extended to a full word integer
     before it is stored in operand 0.

`extzv'
     Like `extv' except that the bit-field value is zero-extended.

`insv'
     Store operand 3 (which must be valid for `SImode') into a
     bit-field in operand 0, where operand 1 specifies the width in
     bits and operand 2 the starting bit.  Operand 0 may have mode
     `QImode' or `SImode'; often `SImode' is allowed only for
     registers.  Operands 1 and 2 must be valid for `SImode'.

     The RTL generation pass generates this instruction only with
     constants for operands 1 and 2.

`sCOND'
     Store zero or nonzero in the operand according to the condition
     codes.  Value stored is nonzero iff the condition COND is true. 
     COND is the name of a comparison operation expression code, such
     as `eq', `lt' or `leu'.

     You specify the mode that the operand must have when you write
     the `match_operand' expression.  The compiler automatically sees
     which mode you have used and supplies an operand of that mode.

     The value stored for a true condition must have 1 as its low bit.
     Otherwise the instruction is not suitable and must be omitted
     from the machine description.  You must tell the compiler
     exactly which value is stored by defining the macro
     `STORE_FLAG_VALUE'.

`bCOND'
     Conditional branch instruction.  Operand 0 is a `label_ref' that
     refers to the label to jump to.  Jump if the condition codes
     meet condition COND.

`call'
     Subroutine call instruction returning no value.  Operand 0 is
     the function to call; operand 1 is the number of bytes of
     arguments pushed (in mode `SImode', except it is normally a
     `const_int'); operand 2 is the number of registers used as
     operands.

     On most machines, operand 2 is not actually stored into the RTL
     pattern.  It is supplied for the sake of some RISC machines
     which need to put this information into the assembler code; they
     can put it in the RTL instead of operand 1.

     Operand 0 should be a `mem' RTX whose address is the address of
     the function.

`call_value'
     Subroutine call instruction returning a value.  Operand 0 is the
     hard register in which the value is returned.  There are three
     more operands, the same as the three operands of the `call'
     instruction (but with numbers increased by one).

     Subroutines that return `BLKmode' objects use the `call' insn.

`return'
     Subroutine return instruction.  This instruction pattern name
     should be defined only if a single instruction can do all the
     work of returning from a function.

`casesi'
     Instruction to jump through a dispatch table, including bounds
     checking.  This instruction takes five operands:

       1. The index to dispatch on, which has mode `SImode'.

       2. The lower bound for indices in the table, an integer
          constant.

       3. The upper bound for indices in the table, an integer
          constant.

       4. A label to jump to if the index has a value outside the
          bounds.  (If the machine-description macro
          `CASE_DROPS_THROUGH' is defined, then an out-of-bounds
          index drops through to the code following the jump table
          instead of jumping to this label.  In that case, this label
          is not actually used by the `casesi' instruction, but it is
          always provided as an operand.)

       5. A label that precedes the table itself.

     The table is a `addr_vec' or `addr_diff_vec' inside of a
     `jump_insn'.  The number of elements in the table is one plus
     the difference between the upper bound and the lower bound.

`tablejump'
     Instruction to jump to a variable address.  This is a low-level
     capability which can be used to implement a dispatch table when
     there is no `casesi' pattern.

     This pattern requires two operands: the address or offset, and a
     label which should immediately precede the jump table.  If the
     macro `CASE_VECTOR_PC_RELATIVE' is defined then the first
     operand is an absolute address to jump to; otherwise, it is an
     offset which counts from the address of the table.

     The `tablejump' insn is always the last insn before the jump
     table it uses.  Its assembler code normally has no need to use
     the second operand, but you should incorporate it in the RTL
     pattern so that the jump optimizer will not delete the table as
     unreachable code.



File: gcc.info,  Node: Pattern Ordering,  Next: Dependent Patterns,  Prev: Standard Names,  Up: Machine Desc

When the Order of Patterns Matters
==================================

Sometimes an insn can match more than one instruction pattern.  Then
the pattern that appears first in the machine description is the one
used.  Therefore, more specific patterns (patterns that will match
fewer things) and faster instructions (those that will produce better
code when they do match) should usually go first in the description.

In some cases the effect of ordering the patterns can be used to hide
a pattern when it is not valid.  For example, the 68000 has an
instruction for converting a fullword to floating point and another
for converting a byte to floating point.  An instruction converting
an integer to floating point could match either one.  We put the
pattern to convert the fullword first to make sure that one will be
used rather than the other.  (Otherwise a large integer might be
generated as a single-byte immediate quantity, which would not work.)
Instead of using this pattern ordering it would be possible to make
the pattern for convert-a-byte smart enough to deal properly with any
constant value.



File: gcc.info,  Node: Dependent Patterns,  Next: Jump Patterns,  Prev: Pattern Ordering,  Up: Machine Desc

Interdependence of Patterns
===========================

Every machine description must have a named pattern for each of the
conditional branch names `bCOND'.  The recognition template must
always have the form

     (set (pc)
          (if_then_else (COND (cc0) (const_int 0))
                        (label_ref (match_operand 0 "" ""))
                        (pc)))

In addition, every machine description must have an anonymous pattern
for each of the possible reverse-conditional branches.  These
patterns look like

     (set (pc)
          (if_then_else (COND (cc0) (const_int 0))
                        (pc)
                        (label_ref (match_operand 0 "" ""))))

They are necessary because jump optimization can turn
direct-conditional branches into reverse-conditional branches.

The compiler does more with RTL than just create it from patterns and
recognize the patterns: it can perform arithmetic expression codes
when constant values for their operands can be determined.  As a
result, sometimes having one pattern can require other patterns.  For
example, the Vax has no `and' instruction, but it has `and not'
instructions.  Here is the definition of one of them:

     (define_insn "andcbsi2"
       [(set (match_operand:SI 0 "general_operand" "")
             (and:SI (match_dup 0)
                     (not:SI (match_operand:SI
                               1 "general_operand" ""))))]
       ""
       "bicl2 %1,%0")

If operand 1 is an explicit integer constant, an instruction
constructed using that pattern can be simplified into an `and' like
this:

     (set (reg:SI 41)
          (and:SI (reg:SI 41)
                  (const_int 0xffff7fff)))

(where the integer constant is the one's complement of what appeared
in the original instruction).

To avoid a fatal error, the compiler must have a pattern that
recognizes such an instruction.  Here is what is used:

     (define_insn ""
       [(set (match_operand:SI 0 "general_operand" "")
             (and:SI (match_dup 0)
                     (match_operand:SI 1 "general_operand" "")))]
       "GET_CODE (operands[1]) == CONST_INT"
       "*
     { operands[1]
         = gen_rtx (CONST_INT, VOIDmode, ~INTVAL (operands[1]));
       return \"bicl2 %1,%0\";
     }")

Whereas a pattern to match a general `and' instruction is impossible
to support on the Vax, this pattern is possible because it matches
only a constant second argument: a special case that can be output as
an `and not' instruction.

A ``compare'' instruction whose RTL looks like this:

     (set (cc0) (minus OPERAND (const_int 0)))

may be simplified by optimization into a ``test'' like this:

     (set (cc0) OPERAND)

So in the machine description, each ``compare'' pattern for an
integer mode must have a corresponding ``test'' pattern that will
match the result of such simplification.

In some cases machines support instructions identical except for the
machine mode of one or more operands.  For example, there may be
``sign-extend halfword'' and ``sign-extend byte'' instructions whose
patterns are

     (set (match_operand:SI 0 ...)
          (extend:SI (match_operand:HI 1 ...)))
     
     (set (match_operand:SI 0 ...)
          (extend:SI (match_operand:QI 1 ...)))

Constant integers do not specify a machine mode, so an instruction to
extend a constant value could match either pattern.  The pattern it
actually will match is the one that appears first in the file.  For
correct results, this must be the one for the widest possible mode
(`HImode', here).  If the pattern matches the `QImode' instruction,
the results will be incorrect if the constant value does not actually
fit that mode.

Such instructions to extend constants are rarely generated because
they are optimized away, but they do occasionally happen in
nonoptimized compilations.

When an instruction has the constraint letter `o', the reload pass
may generate instructions which copy a nonoffsetable address into an
index register.  The idea is that the register can be used as a
replacement offsetable address.  In order for these generated
instructions to work, there must be patterns to copy any kind of
valid address into a register.

Most older machine designs have ``load address'' instructions which
do just what is needed here.  Some RISC machines do not advertise
such instructions, but the possible addresses on these machines are
very limited, so it is easy to fake them.

Auto-increment and auto-decrement addresses are an exception; there
need not be an instruction that can copy such an address into a
register, because reload handles these cases in a different manner.



File: gcc.info,  Node: Jump Patterns,  Next: Peephole Definitions,  Prev: Dependent Patterns,  Up: Machine Desc

Defining Jump Instruction Patterns
==================================

GNU CC assumes that the machine has a condition code.  A comparison
insn sets the condition code, recording the results of both signed
and unsigned comparison of the given operands.  A separate branch
insn tests the condition code and branches or not according its
value.  The branch insns come in distinct signed and unsigned
flavors.  Many common machines, such as the Vax, the 68000 and the
32000, work this way.

Some machines have distinct signed and unsigned compare instructions,
and only one set of conditional branch instructions.  The easiest way
to handle these machines is to treat them just like the others until
the final stage where assembly code is written.  At this time, when
outputting code for the compare instruction, peek ahead at the
following branch using `NEXT_INSN (insn)'.  (The variable `insn'
refers to the insn being output, in the output-writing code in an
instruction pattern.)  If the RTL says that is an unsigned branch,
output an unsigned compare; otherwise output a signed compare.  When
the branch itself is output, you can treat signed and unsigned
branches identically.

The reason you can do this is that GNU CC always generates a pair of
consecutive RTL insns, one to set the condition code and one to test
it, and keeps the pair inviolate until the end.

To go with this technique, you must define the machine-description
macro `NOTICE_UPDATE_CC' to do `CC_STATUS_INIT'; in other words, no
compare instruction is superfluous.

Some machines have compare-and-branch instructions and no condition
code.  A similar technique works for them.  When it is time to
``output'' a compare instruction, record its operands in two static
variables.  When outputting the branch-on-condition-code instruction
that follows, actually output a compare-and-branch instruction that
uses the remembered operands.

It also works to define patterns for compare-and-branch instructions.
In optimizing compilation, the pair of compare and branch
instructions will be combined accoprding to these patterns.  But this
does not happen if optimization is not requested.  So you must use
one of the solutions above in addition to any special patterns you
define.



File: gcc.info,  Node: Peephole Definitions,  Next: Expander Definitions,  Prev: Jump Patterns,  Up: Machine Desc

Defining Machine-Specific Peephole Optimizers
=============================================

In addition to instruction patterns the `md' file may contain
definitions of machine-specific peephole optimizations.

The combiner does not notice certain peephole optimizations when the
data flow in the program does not suggest that it should try them. 
For example, sometimes two consecutive insns related in purpose can
be combined even though the second one does not appear to use a
register computed in the first one.  A machine-specific peephole
optimizer can detect such opportunities.

A definition looks like this:

     (define_peephole
       [INSN-PATTERN-1
        INSN-PATTERN-2
        ...]
       "CONDITION"
       "TEMPLATE"
       "MACHINE-SPECIFIC INFO")

The last string operand may be omitted if you are not using any
machine-specific information in this machine description.  If
present, it must obey the same rules as in a `define_insn'.

In this skeleton, INSN-PATTERN-1 and so on are patterns to match
consecutive instructions.  The optimization applies to a sequence of
instructions when INSN-PATTERN-1 matches the first one,
INSN-PATTERN-2 matches the next, and so on.

INSN-PATTERN-1 and so on look *almost* like the second operand of
`define_insn'.  There is one important difference: this pattern is an
RTX, not a vector.  If the `define_insn' pattern would be a vector of
one element, the INSN-PATTERN should be just that element, no vector.
If the `define_insn' pattern would have multiple elements then the
INSN-PATTERN must place the vector inside an explicit `parallel' RTX.

The operands of the instructions are matched with `match_operands'
and `match_dup', as usual).  What is not usual is that the operand
numbers apply to all the instruction patterns in the definition.  So,
you can check for identical operands in two instructions by using
`match_operand' in one instruction and `match_dup' in the other.

The operand constraints used in `match_operand' patterns do not have
any direct effect on the applicability of the optimization, but they
will be validated afterward, so write constraints that are sure to
fit whenever the optimization is applied.  It is safe to use `"g"'
for each operand.

Once a sequence of instructions matches the patterns, the CONDITION
is checked.  This is a C expression which makes the final decision
whether to perform the optimization (do so if the expression is
nonzero).  If CONDITION is omitted (in other words, the string is
empty) then the optimization is applied to every sequence of
instructions that matches the patterns.

The defined peephole optimizations are applied after register
allocation is complete.  Therefore, the optimizer can check which
operands have ended up in which kinds of registers, just by looking
at the operands.

The way to refer to the operands in CONDITION is to write
`operands[I]' for operand number I (as matched by `(match_operand I
...)').  Use the variable `insn' to refer to the last of the insns
being matched; use `PREV_INSN' to find the preceding insns (but be
careful to skip over any `note' insns that intervene).

When optimizing computations with intermediate results, you can use
CONDITION to match only when the intermediate results are not used
elsewhere.  Use the C expression `dead_or_set_p (INSN, OP)', where
INSN is the insn in which you expect the value to be used for the
last time (from the value of `insn', together with use of
`PREV_INSN'), and OP is the intermediate value (from `operands[I]').

Applying the optimization means replacing the sequence of
instructions with one new instruction.  The TEMPLATE controls
ultimate output of assembler code for this combined instruction.  It
works exactly like the template of a `define_insn'.  Operand numbers
in this template are the same ones used in matching the original
sequence of instructions.

The result of a defined peephole optimizer does not need to match any
of the instruction patterns, and it does not have an opportunity to
match them.  The peephole optimizer definition itself serves as the
instruction pattern to control how the instruction is output.

Defined peephole optimizers are run in the last jump optimization
pass, so the instructions they produce are never combined or
rearranged automatically in any way.

Here is an example, taken from the 68000 machine description:

     (define_peephole
       [(set (reg:SI 15) (plus:SI (reg:SI 15) (const_int 4)))
        (set (match_operand:DF 0 "register_operand" "f")
             (match_operand:DF 1 "register_operand" "ad"))]
       "FP_REG_P (operands[0]) && ! FP_REG_P (operands[1])"
       "*
     {
       rtx xoperands[2];
       xoperands[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);
     #ifdef MOTOROLA
       output_asm_insn (\"move.l %1,(sp)\", xoperands);
       output_asm_insn (\"move.l %1,-(sp)\", operands);
       return \"fmove.d (sp)+,%0\";
     #else
       output_asm_insn (\"movel %1,sp@\", xoperands);
       output_asm_insn (\"movel %1,sp@-\", operands);
       return \"fmoved sp@+,%0\";
     #endif
     }
     ")

The effect of this optimization is to change

     jbsr _foobar
     addql #4,sp
     movel d1,sp@-
     movel d0,sp@-
     fmoved sp@+,fp0

into

     jbsr _foobar
     movel d1,sp@
     movel d0,sp@-
     fmoved sp@+,fp0


